\documentclass[11pt, oneside, listof=totoc]{scrbook}

\counterwithout{figure}{chapter}

\usepackage[linear]{handout}
\usepackage{scrhack}
% \setlist{nosep}

\input{tikz-input.tex}

%% Quantum Circuits %% 
\usepackage{qcircuit}

%% Style for Listings %%
\usepackage{jlcode}
\lstdefinestyle{mystyle}{
    % basicstyle={\fontfamily{fvm}\selectfont},
    % backgroundcolor=\color{backcolour},
    % commentstyle=\color{codegreen},
    % keywordstyle={\color{inactivecolor}},
    % stringstyle={\color{stringcolor}},
    % identifierstyle={\color{identifiercolor}},
    numberstyle=\tiny\color{gray},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=12pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    float = H,
    frame = trBL,
    frameround=fttt,
}

\lstset{style=mystyle}

\renewcommand{\lstlistingname}{Code} % adjusts Listings caption and reference lst
\renewcommand{\lstlistlistingname}{List of Code Snippets}

\crefname{lstlisting}{code}{codes}

%% EULER Fonts %%
% \usepackage[T1]{fontenc}
% \usepackage{textcomp}
% \usepackage{opensans}
% \usepackage[boldsans]{ccfonts}
% \usepackage[euler-digits]{eulervm}

%% Math Macros %%
\renewcommand{\H}{\mathcal{H}}
\renewcommand{\O}{\mathcal{O}}
\renewcommand{\HH}{\mathscr{H}} 

\renewcommand{\u}{0}
\renewcommand{\d}{1}
\renewcommand{\r}{+}
\renewcommand{\l}{-}

\newcommand{\ku}{\ket{0}}
\newcommand{\kd}{\ket{1}}
\newcommand{\kr}{\ket{+}}
\newcommand{\kl}{\ket{-}}

\newcommand{\UU}{\mathcal{U}}

%% Image Path %%
\graphicspath{{images/}}

%% TOC Setup %%
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

\title{Quantum Cellular Automata}
\subtitle{NIUS Physics (Batch 20) \\ Mid-Term Report \\ Camp: 20.2}
\author{
    Piyush Kumar Singh\thanks{\mailto{pks22ms027@iiserkol.ac.in}} \\ {\large Student Code: P49-2023} \\ {\large IISER Kolkata} 
    \and
    % Rhythm Anand\thanks{\mailto{rhythm.anand@students.iiserpune.ac.in}} \\ {\large IISER Pune}
    % \and
    Sambuddha Sanyal\thanks{\mailto{sambuddha.sanyal@iisertirupati.ac.in}} \\ {\large IISER Tirupati}
}
\date{
    January 26, 2024\\[3ex]
    \includegraphics[width = 0.7\textwidth]{quantum-xkcd-better.png}
}

\changemaincolor{Emerald}
\changesecondcolor{Periwinkle}

% \usepackage{biblatex}
\addbibresource{references.bib}

\hypersetup{
    pdftitle={Quantum Cellular Automata},
    pdfauthor={Piyush Kumar Singh, Sambuddha Sanyal},
    pdfkeywords={physics, cellular automata, quantum cellular automata, thermalization},
    linktocpage=true
}

\begin{document}
\frontmatter
\begin{titlepage}
    \let\newpage\relax%
    \singhtitle
\end{titlepage}

\chapter*{Acknowledgement}
\addcontentsline{toc}{chapter}{Acknowledgement}

{\large\noindent
    This work was supported by the National Initiative on Undergraduate Science (NIUS) undertaken
    by the Homi Bhabha Centre for Science Education, Tata Institute of Fundamental Research
    (HBCSE-TIFR), Mumbai, India. We acknowledge the support of the Department of Atomic
    Energy, Govt. Of India, under Project Identification No. RTI4001.\\

    I want to thank my project instructor, Sambudhha Sanyal, for his guidance, expertise, and unwavering commitment throughout this project. His mentorship has been instrumental in shaping the direction and success of our research endeavors. We are truly grateful for his dedication and encouragement, which have significantly enriched our learning experience within the framework of the NIUS program.
}

\tableofcontents
% \lstlistoflistings

\mainmatter

\chapter{Introduction}

% \lipsum[1]\cite{Hadeler2017}

Cellular automata are discrete mathematical models used to simulate complex systems. John von Neumann first introduced the concept \cite{Neumann1966} in 1966. In 1970, an article written by Martin Gardner \cite{Gardner1970} introduces us to a compelling use case of this abstract concept, ``The Game of Life,'' invented by J. H. Conway.

% In classical cellular automata, the system is divided into discrete cells arranged in a grid. Each cell can be in one of a finite number of states. The state of a cell is typically updated over discrete time steps according to a set of rules based on the states of its neighbouring cells.

In a conference in 1982, R. P. Feynman expressed his view (or dream) of using `Quantum Physics' in computers \cite{Feynman1982} to simulate complex physical systems using the idea of density matrix (proposed by Neumann in 1955 \cite{Neumann2018}); building on his idea Feynman introduced the world to a weird collaboration named ``Quantum Cellular Automata'' (QCA) in an article published in 1986 \cite{Feynman1986}.

And there are multiple reasons why we should care about QCAs. First, this is part of a broad field of `Quantum Information Processing,' any development in QCA may help us understand how we can harness quantum properties for computation. Second, the classical systems exhibit some new emergent behaviors, so we want to know if we can also have these emergent behaviors in QCAs.

% When this abstract concept is combined with seemingly weird notions of `Quantum Mechanics,' we get Quantum Cellular Automata (QCA).

Also, in the later part of the discussion, we will see the application of these `discrete' quantum systems (in the form of ``\impt{Random Quantum Circuits}''\cite{Fisher2023}), observing some of the various emergent properties like:
\setlist{nolistsep}
\begin{enumerate}[(a), noitemsep]
    \item Fidelity,
    \item Information spread (encoded as \emph{Operator Spread}).
\end{enumerate}

\section{Cellular Automata}

A cellular automaton (CA) is a group of ``colored'' cells on a predetermined-shaped grid that follows a set of rules depending on nearby cell states to evolve over many discrete time steps. After that, the rules are applied repeatedly for as many time steps as needed.

It turned out that reaction-diffusion systems, biological pattern development, fluid flows, and traffic models are only a few real-world uses for CAs. Lattice gas cellular automata are a specific type of CA used to simulate fluid dynamics. The Navier-Stokes equation can be obtained by selecting the appropriate model. Lattice Boltzmann models have taken their place, using continuous functions at the lattice locations rather than discrete variables. More aspirationally, CAs have been proposed as discrete physics models with many desirable characteristics, such as dynamical homogeneity and localization. But, while this is a fascinating idea, physics is ultimately quantum, and CAs cannot adequately represent, e.g., Bell inequality violation, which occurs from quantum entanglement.

Before giving a formal definition, let's look at an example \cite{Farrelly2019}:
\begin{example}[Rule Number 110]
    \label{eg:rule110}
    Consider a one-dimensional array of bits (\ie cells having two states, namely `0' or `1'). The update rule of a bit is dependent on the initial state of that bit as well as the state of its neighboring bits. The rule can be summarized as follows:
    \begin{table}[H]
        \centering
        \begin{tabular}{ | c | c | c | c | c | c | c | c | c | }
            \hline
            Initial state of a bit and its neighbours & 111 & 110 & 101 & 100 & 011 & 010 & 001 & 000 \\
            \hline
            New state of middle bit                   & 0   & 1   & 1   & 0   & 1   & 1   & 1   & 0   \\
            \hline
        \end{tabular}
        \caption{Update rule for a \textit{one}-dimensional CA}
        \label{tab:rule110}
    \end{table}
    We named this update rule as \verb|Rule 110| because if you treat the last row of the table as a binary number, it converts to 110 in the decimal system. This CA can simulate a Turing machine efficiently (with only polynomial overhead).
    \begin{figure}[H]
        \centering
        \includegraphics[width = \textwidth]{rule110_cellular_automaton.png}
        \caption{An example of a CA evolution for the rule 110 CA, with time going up. Bits with value 1 are
            represented by the yellow squares, while blue squares represent 0.}
        \label{fig:rule110}
    \end{figure} \noindent

\end{example}
Cheung in \cite{Cheung2007}, defined CA as follows:
\begin{definition}[Cellular Automata]
    A Cellular Automaton is a 4-tuple \(\qty(L, \Sigma, \mathcal{N}, f)\) consisting of a $d$-dimensional lattice of cells indexed by integers, $L = \Z^d$, a finite set $\Sigma$ of cell states, a finite neighbourhood scheme $\mathcal{N} \subseteq \Z^d$, and a local transition function $f: \Sigma^{\mathcal{N}} \to \Sigma$.
\end{definition}

% There are a few unique characteristics of this local transition function \(f\). Consider a cell \(x \in L\)
To better understand this local transition function \(f\), consider a cell \(x \in L\). This function takes the state of the neighbors of \(x\) as the argument, which is indexed by the set \(\mathcal{N}\) at the current time \(t \in \Z\) to spit out the state of cell $x$ at time $t + 1$.

\noindent This observation points us towards two important properties of cellular automata that will help us understand why CAs are very helpful in simulating certain systems:

\begin{itemize}
    \item cellular automata are \vocab{space-homogeneous} \ie the local transition function performs the same function at each cell.
    \item Also, cellular automata are \vocab{time-homogeneous} \ie the local transition function does not depend on the current time $t$.\footnote{We will review these properties in detail in \cref{ssec: locality,ssec: universality}}
\end{itemize}

\noindent We can define the current state of the lattice (or CA) as a \emph{configuration} \(C \in \Sigma^{L}\), which has the information about the state of each cell at time \(t\). Now, using this idea, we can define a `\emph{global}' transition function \(F: \Sigma^{L} \to \Sigma^{L}\), which acts on the entire latter rather than on individual cells and spits out another configuration \(C'\) for the lattice at time \(t+1\).

\begin{remark}[Revisiting Rule 110]
    Observe the \cref{eg:rule110}; we can fit this scenario in the definition. In this case \(L = \Z\), \(\Sigma = \qty{0, 1}\), for $i^{\text{th}}$ cell \(\mathcal{N} := \qty{i-1,~ i,~ i+1}\) and \(f\) is defined according to the update rule specified in \cref{tab:rule110}.
\end{remark}

% \pagebreak
\subsection{Characteristics of Cellular Automata}

In the definition and example, we have used a few terms; now we will define them (and these will be the main characteristics of cellular automata):
\begin{list}{}{}
    \item[\bfseries Discrete Space-Time:] In our discussion, we have defined the lattice \((L)\) to be \(d\)-dimensional integer space, which makes our area of interest a discrete space. Our evolution to the next state is also discrete since we evolve our states from \(t \to t+1\) (or predefined time steps).

    \item[\bfseries Finite State Set:] The set \(\Sigma\) is finite \ie every cell has only finitely many states of being in. Generally, in classical systems, we have state set \(\Sigma = \qty{0, 1}\), also called `binary cellular automata.'

    \item[\bfseries Cell/Cell-state:] Every space-position vector \(i \in L = \Z^d\) identifies a cell which contains a cell-state \(c_i \in \Sigma\).

    \item[\bfseries Configuration:] A configuration \(C\) is the concatination of all cell-states over the entire lattice \(L\) at a given time \(t\) which means that every configuration is an element of set \(\Sigma^L\).

    \item[\bfseries Local Transition Function:] We know time is also discrete in our system (with a predefined time step). We use a local transition function \(f\) that defines the state of every cell after each time evolution. We refer to this function as a local function, as it only takes the states of the `neighboring' cells as an argument.

    \item[\bfseries Neighbourhood Scheme:] As we have defined, the outcome of our local function at any cell \(i\) depends on the set of cell-states of neighboring cells. This set is defined by the neighborhood scheme \(\mathcal{N}\) on cellular automata.

    \item[\bfseries Global Function:] For a given lattice \(L\) (with a defined neighborhood scheme), the local transition function \(f\) imposes a global transition function \(F\) on the set of all possible configurations. This global function determines the \emph{space}/\emph{time} behavior of the cellular automaton on an initial configuration.
\end{list}

\subsection{Locality} \label{ssec: locality}

% The word locality has a defined meaning in day-to-day conversations, but here, this locality means something more than that. 
In physics, locality implies we are talking about the \impt{Principle of Locality}, which states that \uline{an object is influenced directly only by its immediate surroundings}. If a theory that includes this principle is said to be a ``local theory.'' This idea of locality evolved from the classical field theory; building upon this idea, if an event at a point is cause for an effect at another point, a wave or a particle must travel through space-time between the two points, carrying the influence.

Einstein postulated that causal influence couldn't be transmitted between two points faster than the speed of light \(c\), in the \vocab{Special Theory of Relativity}, which means that if two points are spacelike separated, they can't influence each other. % This limit on speed also relates to the locality and causality

In the context of cellular automata, we know that the state of a cell is only influenced by the states of finite neighbors (decided by neighborhood scheme). Since the state of any cell is influenced by its surroundings, we can say that the cellular automata theory is local.

\begin{remark}[Relation between locality and relativistic causality]
    Causality means an effect can only occur from a cause in the past light cone of that event. Similarly, a cause can only affect an event in the future light cone.

    The requirement that causal influences cannot propagate faster than the speed of light ensures that physical interactions remain local, implying distant events cannot have instantaneous effects on each other.
\end{remark}

\subsection{Universality} \label{ssec: universality}
Universality refers to the idea that certain phenomena or behaviors are independent of the specific details of a system, and these phenomena are governed by more basic physical principles or underlying symmetries of the system.

\noindent There are multiple scenarios in which we get this universality from the nature:
\begin{description}
    \item[\normalfont\sffamily \uline{Quantum Computing:}] A specific set of quantum gates can efficiently simulate any other quantum circuit, and this set is called the universal gates. So this feature makes quantum computers universal as their behavior is the same, independent of the specific details.

    \item[\normalfont\sffamily \uline{Statistical Mechanics:}] The distribution of particle velocities in a gas, as described by the Maxwell-Boltzmann distribution, is universal for classical gases, independent of the specific nature of the particles.
\end{description}

Cellular automata are universal by definition as they evolve under a predefined rule (or local transition function) irrespective of their initial state and the time step at which we apply the evolution.

\section{Quantum Cellular Automata}
R. P. Feynman introduced the idea of Quantum Cellular Automata with a vision that it can be used to simulate `Quantum Systems' as we don't have a classical analog of many quantum phenomena. In \cite{Watrous1995}, he has proven that QCAs are an alternative paradigm of quantum computers. They have shown QCAs to be universal, implying they could efficiently simulate a quantum Turing machine.

This demonstration showed that QCAs are very important for quantum computers, so many have tried to formulate a theory. But there was an enormous challenge in front of the scientists: after some local function has updated one cell, we will lose the information about the state of the cell at time \(t\) as we require it for updating other cells. So somehow, we have to clone the state of this cell to some other cell, but by the \vocab{no-cloning theorem}, it is simply impossible.\\

Werner and Schumacher (in \cite{Werner2004}) gave an axiomatic definition for QCAs to avoid these theoretical challenges. Farrelly in \cite{Farrelly2019} restated the definition as follows:

\begin{definition}[Quantum Cellular Automata]
    A Quantum Cellular Automaton is a spatial lattice \(L = \Z^d\), with a quantum system on each lattice point \(x \in L\) and evolves over discrete timesteps via some unitary operators that are locality preserving.
\end{definition}

If we look at the definition, it becomes evident that locality here refers to \vocab{relativistic causality}. As we have defined our system on a discrete spacetime, we have assumed the maximum propagation speed of information. This definition guarantees locality; combined with unitarity, we get a QCA.

\begin{moral}
    We claim to simulate physics with these discrete spacetime systems in this discussion. However, all theoretical physics works with continuous spacetime.

    \noindent Can we discretize whole physics is a nontrivial and exciting question on its own.
\end{moral}

\subsection[An example of QCA]{An example of QCA \cite{Farrelly2019}}\label{ssec:initial-rqc}

For a typical quantum system (not a QCA), the dynamics is determined by the Schr\"odinger equation. However, our systems are defined on discrete spacetime, so there is no corresponding Schr\"odinger equation. So, we work with unitary operators that evolve the state every time step.

Take a discrete line of qubits with position labelled by \(x \in \qty{0,~1,~2,\dots,N-1}\), where \(N\) is even. Consider the `depth-two' circuit of unitary operators; say, the unitary operator \(V\) acts on two qubits at a time named \(2 n\) and \(2 n - 1\). The unitary operator \(W\) acts on two qubits named \(2n+1\) and \(2n\) (see \cref{fig:qca-example}).

\begin{figure}[H]
    \centering
    \includegraphics[width = 0.6\textwidth]{qca-example.png}
    \caption{A simple example of a QCA unitary.}
    \label{fig:qca-example}
\end{figure} \noindent
The yellow boxes represent qubits, while the red and blue rectangles represent the two-qubit local unitaries that implement the dynamics over one timestep.\\
So, the unitary operator for this `depth-two' circuit will be given by
\begin{equation*}
    U = \prod_{n} V_{2n, ~ 2n-1} \prod_{m} W_{2m-1, ~2m}
\end{equation*}
The order of application of these unitary operators doesn't matter as they commute.


\chapter{Random Quantum Circuits}

Discrete quantum circuits are good examples of QCAs (see \cref{ssec:initial-rqc}). In \cite{Fisher2023}, they have extended this idea of quantum circuits as QCAs to incorporate an element of randomness into the local unitary gates (or operations). They also included measurements of quantum circuits (which are irreversible and non-local). This kind of quantum circuit is known as ``Random Quantum Circuit (RQC).''

This discussion will use a simple discrete-time model for many-body quantum systems. This model's lattice of spins (qubits) evolves by applying local unitary gates and projective measurements. This discrete-time structure can be seen as an example of `\vocab{Totterization}' of a continuous-time Hamiltonian evolution \(\qty[\ie ~ e^{i \hat{H} t / \hslash}]\), assuming the time-step to be finite \(\qty(\ie ~ t \in \Z)\), which also implies that energy is not conserved in this approach.

\section{Methodology}

In this section, we will construct the system used in this analysis. And also go through some of the mathematical tools required to understand ``\impt{Quantum Entanglement}.''

\subsection{Defining System}
Let a \(d\)-dimensional lattice \(L = \Z^{d}\) composed of qubits (or in general \(q\)-level systems ``\vocab{qubits}'') which represents a \(d\)-dimensional quantum many-body system arranged in a spatially local manner. The discrete-time evolution of such a quantum many-body system by applying local unitary gates defines a quantum circuit. We will restrict our discussion to
\begin{enumerate}[(i), noitemsep]
    \item local quantum gates -- unitary transformation acting on a few neighbouring qubits,
    \item local projective measurements -- observations which leave the measured qubit in a state with definite eigenvalue of the measured operator.
\end{enumerate}

\subsection{Quantum Entanglement}

In 1935 \cite{Einstein1935}, Albert Einstein, Boris Podolsky, and Nathan Rosen published a paper on counterintuitive predictions that quantum mechanics makes for pairs of objects prepared together in a particular way. In this study, the three formulated a thought experiment (today known as EPR-paradox) to show that ``the quantum-mechanical description of physical reality given by wavefunctions is not complete.''

\begin{definition}[Quantum Entanglement]
    An entangled system is one whose quantum state cannot be separated as a tensor product of the quantum states of its local constituents.
\end{definition}

Consider two arbitrary quantum many-body systems $A$ and $B$, with respective Hilbert spaces \(\H_{A}\) and \(\H_{B}\). The composite Hilbert space is a tensor product given by \(\H:= \H_{A} \otimes \H_{B}\). Say system \(A\) is in a state \(\ket{\Psi}_A\) and \(B\) is in \(\ket{\Psi}_B\), the state of the composite system is given by \(\ket{\Psi}_A \otimes \ket{\Psi}_B\).
\begin{remark}[Pure and Entangled state]
    If the state of the composite system can be expressed in the tensor product of the states of individual systems, then we call this composite state a separable state or \vocab{pure state}.

    \noindent Not all states are pure states. Let \(\qty{\ket{\mu}_A}\) be a set of basis for the space \(\H_A\) and set \(\qty{\ket{\nu}_B}\) be a basis for the space \(\H_B\). The most general state in \(\H\) is of the form
    \begin{equation}\label{eq:tensor_state}
        \ket{\Psi} = \sum_{\mu,\!\nu}^{} c_{\mu \nu} \ket{\mu}_A \otimes \ket{\nu}_B
    \end{equation}
    This state is separable if and only if there exist vectors \(\qty[c_{\mu}^{A}]\) and \(\qty[c_{\nu}^{B}]\) such that \(c_{\mu \nu} = c_{\mu}^{A} c_{\nu}^{B}\), yielding \(\ket{\Psi}_A:= \sum_{\mu} c_{\mu}^{A} \ket{\mu}\) and \(\ket{\phi}_B:= \sum_{\nu} c_{\nu}^{B} \ket{\nu}\). And it is inseparable if such vectors do not exist. If a state is inseparable, it is called an `\vocab{entangled state}.'
\end{remark}

\subsubsection{Density Matrix}

The density matrix language provides a convenient way to describe quantum systems whose state is unknown.
\begin{definition}[Density Matrix]
    Suppose a quantum system is in one of several states \(\ket{\Psi_i}\), with respective probabilities \(p_i\). We define \(\qty{p_i, \ket{\Psi_i}}\) an \emph{ensemble of pure states}. The density matrix can be defined as follows for this quantum system
    \[
        \rho \equiv \sum_{i} p_i \ket{\Psi_i} \bra{\Psi_i}
    \]
\end{definition}
{\bfseries Properties of density matrix:}
\begin{itemize}[noitemsep]
    \item \(\rho\herm = \rho\)
    \item \(\Tr\rho = 1 \quad \implies \quad \sum_{i} p_i = 1\)
    \item \(\Tr \rho^2 \le 1 \quad (\text{equality holds for a pure ensemble})\)
\end{itemize}
{\bfseries \uline{Reduced Density Function:}}\\
Consider a quantum many-body system composed of \(N\) qubits and defined by a wavefunction \(\ket{\Psi}\), which is bipartitioned into a subset of spins \(A\), with Hilbert space dimension \(D_{A}\), and its complement \(\bar{A}\), with Hilbert space dimension \(D_{\bar{A}}\).

Generally, there is no way to associate a pure state to a sub-system $A$. However, associating a density matrix with this sub-system is still possible. Let \(\rho_{T} = \ket{\Psi} \bra{\Psi}\) which is the projection operator onto this composite state. The density matrix for sub-system \(A\) is defined as a \vocab{partial trace} of \(\rho_T\) over the basis \(\qty{\ket{\nu}}\) of sub-system \(\bar{A}\):
\begin{equation}
    \rho_A := \sum_{\nu} \qty(\I{A} \otimes \bra{\nu}_{\bar{A}}) \qty(\ket{\Psi} \bra{\Psi}) \qty(\I{A} \otimes \ket{\nu}_{\bar{A}}) = \Tr_{\bar{A}} \ket{\Psi} \bra{\Psi}
\end{equation}
where, \(\I{A}\) is the identity operator in Hilbert space \(\H_A\). \(\rho_A\) is also referred to as \emph{reduced density matrix} of \(\rho_T\) on sub-system \(A\), encodes all operator expectation values solely within region $A$.

\subsubsection{Entanglement Entropy}

\begin{definition}[Entanglement Entropy]
    The entanglement entropy measures the degree of quantum entanglement between two subsystems constituting a two-part composite quantum system.
\end{definition}
Continuing the discussion of \(N\) qubits system, which has been bipartite into two sub-systems \(A\) and \(\bar{A}\).
There are multiple ways to define entanglement entropy for these two sub-systems; a few of them are listed below:
\begin{list}{}{}
    \item[\uline{von Neumann Entropy:}] For a bipartite system, von Neumann entropy \(S\) is defined as follows:
        \begin{equation}
            S_{A} = - \Tr(\rho_{A} \ln \rho_{A}) = - \Tr(\rho_{\bar{A}} \ln \rho_{\bar{A}}) = S_{\bar{A}}
        \end{equation}

    \item[\uline{\(n^\text{th}\) R\'enyi Entropy:}] \(S_{A}^{(n)} = \ln(\Tr \rho_{A}^n) / (1 - n)\), and as \(n \to \infty\), \(S_A^n \to S_A\) \ie the von Neumann entropy.
\end{list}


\section{A four-qubit example of RQC}

In this section, we will see what a local unitary operator is in light of quantum circuits and what a projective measurement is. Then, we will work out a discrete-time evolution of a four-qubit system under this local unitary operator and projective measurement numerically.

\subsection{Basics of Quantum Computer -- for a single qubit}\label{ssec:quantum-computer}
For a single qubit, we have a finite state space \(\Sigma = \qty{0, 1}\), so we can infer that Hilbert space \(\H\) for this system is 2-dimensional. The state set can be seen as eigenvalues of a Hermitian operator (to be precise, a Pauli matrix) \(Z\). With these assumptions, we can define the eigenbasis for this Hilbert space \(\H\) as
\begin{equation}
    \B_Z = \qty{\ku = \ket{\uparrow} = \mqty(1 \\ 0),~ \kd= \ket{\downarrow} = \mqty(0 \\ 1)}
\end{equation}
This basis set is sometimes referred as ``\emph{computational basis}.'' Similarly, we can define the other two sets of eigenbasis corresponding to the two remaining Pauli matrices.
\begin{equation}
    \B_X = \qty{\kr = \ket{\rightarrow} = \frac{1}{\sqrt{2}} \qty(\ku + \kd),~ \kl = \ket{\leftarrow} = \frac{1}{\sqrt{2}} \qty(\ku - \kd)}
\end{equation}
In general, the time evolution of a quantum system (which is described by a wavefunction \(\ket{\Psi}\) at time \(t = 0\)) under a given Hamiltonian \(\mathscr{H}\) which is represented by a matrix \(\O\) is provided by
\[
    \ket{\Psi (t)} = \UU(t) \ket{\Psi}, \qquad \UU(t) := \exp(- i \O \frac{t}{\hslash})
\]
For a single qubit, all possible Hamiltonians are \(2 \times 2\) Hermitian operator, which can be written as a linear combination (over \(\R\)) of the three ``\vocab{Pauli Matrices}'' and the identity matrix. Define \(S = \qty{\I{}, X, Y, Z}\)
\begin{equation}
    X = \mqty(0 & 1 \\ 1 & 0), \qquad Y = \mqty(0 & -i \\ i & 0), \qquad Z = \mqty(1 & 0 \\ 0 & -1), \qquad \I{} = \mqty(1 & 0 \\ 0 & 1).
\end{equation}
Using this construction, we can decompose any Hamiltonian operator \(\O\) as
\[
    \O = \sum_{S} c_S S = c_{\I{}} \I{} + c_X X + c_Y Y + c_Z Z
\]
the coefficients in this expansion are real and given by \(c_S = \half \Tr(S \O)\). The corresponding unitary can be written as
\[
    u = \exp(- i \sum_{S} h_S S)
\]
where, the coefficients \(h_S\) are real.\\
{\bfseries \uline{Hadamard Gates:}} This gate is often referred as ``superposition gate'', and represented as \(H\) in quantum circuits. It maps the computational basis as follows:
\begin{equation*}
    \ku \xmapsto{H} \frac{\ku + \kd}{\sqrt{2}} = \kr \quad ; \quad \kd \xmapsto{H} \frac{\ku - \kd}{\sqrt{2}} = \kl
\end{equation*}
The name superposition is evident after looking at the map, as it creates an equal superposition state. From the map itself, we can compute the matrix representation as
\begin{equation}\label{eq:hadamard}
    H = \frac{1}{\sqrt{2}} \mqty(1 & 1 \\ 1 & -1).
\end{equation}

\noindent {\bfseries \uline{Quantum Random Walk:}}\\
Consider a quantum system composed of one qubit whose dynamics are governed by unitary gates and projective measurements. If the qubit is in a pure state, then the state is a point on the Bloch sphere, defined by the polarization vector $(\expval{X}, \expval{Y}, \expval{Z})$. Unitary transformations rotate the state vector on the ``\vocab{Bloch Sphere}.'' A projective measurement, say along \(Z\), causes a stochastic jump to the north or the south pole, depending upon the measurement outcome.

Due to this randomness, an arbitrary sequence of unitaries and measurements gives a \vocab{Random Walk} on the Bloch Sphere, also called ``\impt{Quantum Random Walk}.''

\subsubsection{Two qubit system and controlled gates}

We define the system's state by tensor product for a pair of qubits. Let the two qubits be indexed as \(1, ~2\), so the Hilbert space of the composite system is \(\H_{12} := \H_1 \otimes \H_2 = \H^{\otimes 2}\), keep in mind \(\H_1 = \H_2 = \H = \Span(\ku, \kd)\). Recall \cref{eq:tensor_state}, any general state of this system \(\ket{\Psi} \in \H_{12}\) can be written as
\[
    \ket{\Psi} = \sum_{i, j \in \H} c_{i j} \ket{i}_1 \otimes \ket{j}_2
\]
Extending the same idea of the tensor product to the operators, any Hermitian operator \(\O\) may be written as a sum of tensor products of these operators acting on two qubits. To reduce the confusion, consider we apply a one qubit gate \(G\) to qubit one, and we don't disturb the second qubit (or use identity operator), and then the operator will be denoted as
\[
    G_1 = G \otimes \I{}
\]
observe the \(1\) in subscript of \(G\), this represents that we have applied \(G\) on qubit one alone.\\

\noindent {\bfseries \uline{Controlled Gates:}} Controlled gates act on two or more qubits, where one or more qubits act as a control for some operation. We will restrict ourselves to two-qubit controlled gates.

\noindent Consider a unitary operator \(U\),
\[
    U = \mqty(u_{00} & u_{01} \\ u_{10} & u_{11}).
\]
And we want to apply this operator on qubit 2 when controlled by qubit 1. This statement can be rephrased as `if the control qubit is in state \(\ku\), then do nothing, but if it is in state \(\kd\), then apply the unitary gate \(U\) on target qubit.' Say this `\vocab{control-U}' gate is represented as \(CU\) in quantum circuits, and this gate maps the computational basis as follows:
\begin{align*}
     & \ket{\u \u} \xmapsto{CU} \ket{\u \u}      \\
     & \ket{\u \d} \xmapsto{CU} \ket{\u \d}      \\
     & \ket{\d \u} \xmapsto{CU} \kd \otimes U\ku \\
     & \ket{\d \d} \xmapsto{CU} \kd \otimes U\kd \\
\end{align*}
With this mapping, we can compute the matrix representation of \(CU\) as
\begin{equation}
    % CU = \mqty(\mqty{\imat{2}} & \mqty{\zmat{2}{2}} \\ \mqty{\zmat{2}{2}} & \mqty{u_{00} & u_{01} \\ u_{10} & u_{11}})
    CU = \mqty(
    1 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 \\
    0 & 0 & u_{00} & u_{01} \\
    0 & 0 & u_{10} & u_{11}
    )
\end{equation}
We can have a Hamiltonian representation for this controlled unitary operation as
\begin{equation}\label{eq:CU-exp}
    CU = \exp(- i \frac{\pi}{4} [\I{} - Z_1][\I{} - U_2])
\end{equation}
here, \(\I{}\) represent a \(4 \times 4\) identity matrix; also take a note about subscripts in \(Z\) and \(U\) gates.

\subsection{Toy example}

In this example, we will see how these different gates and concepts can result in good results.\hfill \\

\noindent For our toy example, we will evolve our system under `control-Hadamard gate' ($CH$). We will do a projective measurement of our system after the unitary transformation.

Recall matrix representation of Hadamard gate from \cref{eq:hadamard}. Using the time-evolution form, we can find the matrix of the control Hadamard gate (given in \cref{eq:CU-exp}). We have
\begin{equation*}
    CH = \exp(- i \frac{\pi}{4} [\I{} - Z_1][\I{} - H_2])
\end{equation*}
And using \href{https://www.wolfram.com/mathematica/}{\texttt{Mathematica}}, we can compute the exact form of the matrix (see \cref{lst:CH-mat})
\begin{equation}
    CH = \mqty(
    1 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 \\
    0 & 0 & \frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\[2.5ex]
    0 & 0 & \frac{1}{\sqrt{2}} & - \frac{1}{\sqrt{2}}
    )
\end{equation}

Since measurements are very non-trivial in quantum mechanics, and we don't have any classical analog of the same, it isn't easy to simulate using classical systems. We will use projective measurements (of \(Z\)) in our discussion as we can find the matrix for the same (see \cref{ssec:measurement}). Say we want to project the state of a qubit in \(Z\) basis so that we can use the projection operator given by
\begin{equation*}
    P_{\u} = \ku \bra{\u} = \mqty(1 & 0 \\ 0 & 0) \qquad \qquad P_{\d} = \kd \bra{\d} = \mqty(0 & 0 \\ 0 & 1)
\end{equation*}
These matrices will be used to calculate the next state after we make a projective measurement for a single qubit. For that, we calculate the corresponding probability as
\begin{equation*}
    p_\u = \ev**{P_{\u}}{\psi}
\end{equation*}
So, the state after the measurement will be given by (considering renormalization):
\begin{equation}
    \ket{\psi_m} = \frac{{P_{\u}} \ket{\psi}}{\sqrt{p_\u}}
\end{equation}

For our example, say we want to measure the third qubit in \(\ku\) state, so the corresponding matrix of projection will be as follows:
\begin{equation*}
    P_{\u}^{(3)} = \I{} \otimes \I{} \otimes P_{\u} \otimes \I{}
\end{equation*}

% \noindent{\bfseries \uline{System construction:}}\\
\subsubsection{System construction}
\begin{example}[Four Qubit QC]
    \label{eg:toy-model}
    Consider a quantum many-body system composed of four qubits evolving through time under a unitary operator ($CH$) arranged in a specific way (brickwork structure, see \cref{sec:brickwork}). After the evolution, we project the third qubit in the state \(\kd\). For a schematic diagram of the quantum circuit of this example, see \cref{fig:toy_model}. We prepare our system's initial state as follows:
    \begin{equation*}
        \ket{\Psi} = \kr \otimes \kl \otimes \kr \otimes \kl = \ket{\r\l\r\l}
    \end{equation*}
\end{example}
Generally, qubits are initialized in the state \(\ku\), so we must create the qubits in our desired state using appropriate unitary transformations (see the use of \(X\) and \(H\) gates in the circuit).

\begin{figure}[H]
    \[
        \Qcircuit @C=2em @R=2em @!C {
        & \mbox{\hspace{1.2em}Desired states} &                            &                                    &          & \mbox{Generation 1}           &     \\
        \lstick{\ku} & \qw                                 & \gate{H} \barrier[-2em]{3} & \ustick{\kr} \qw \barrier[-2em]{3} & \ctrl{1} & \qw                           & \qw \\
        \lstick{\ku} & \gate{X}                            & \gate{H}                   & \ustick{\kl} \qw                   & \gate{H} & \qw                           & \qw \\
        \lstick{\ku} & \qw                                 & \gate{H}                   & \ustick{\kr} \qw                   & \ctrl{1} & \meterB{\color{FireBrick}\kd} & \qw \\
        \lstick{\ku} & \gate{X}                            & \gate{H}                   & \ustick{\kl} \qw                   & \gate{H} & \qw                           & \qw
        \gategroup{2}{5}{5}{7}{1em}{^\}}
        \gategroup{2}{5}{5}{7}{1em}{_\}}
        \gategroup{2}{1}{5}{3}{1em}{^)}
        }
    \]
    \caption{Quantum circuit of toy model}
    \label{fig:toy_model}
\end{figure}

\subsubsection{Calculating Final State}

Now we know our quantum circuit, so we find the final state using a classical simulator (using \href{https://julialang.org/}{Julia} see \cref{lst:toy-final}). Define the unitary transformation matrix as \(U_1 = CH \otimes CH\), and we can visualize the state evolution as follows:
\begin{equation*}
    \ket{\Psi} = \mqty(
    0.25+0.0 i  \\
    -0.25+0.0 i \\
    0.25+0.0 i  \\
    -0.25+0.0 i \\
    -0.25+0.0 i \\
    0.25+0.0 i  \\
    -0.25+0.0 i \\
    0.25+0.0 i  \\
    0.25+0.0 i  \\
    -0.25+0.0 i \\
    0.25+0.0 i  \\
    -0.25+0.0 i \\
    -0.25+0.0 i \\
    0.25+0.0 i  \\
    -0.25+0.0 i \\
    0.25+0.0 i
    ) \xrightarrow{U_1}
    \mqty(
    0.25+0.0 i \\
    -0.25+0.0 i \\
    0.0 i \\
    0.35+0.0 i \\
    -0.25+0.0 i \\
    0.25+0.0 i \\
    0.0 i \\
    -0.35+0.0 i \\
    0.0 i \\
    0.0 i \\
    0.0 i \\
    0.0 i \\
    0.35+0.0 i \\
    -0.35+0.0 i \\
    0.0 i \\
    0.5+0.0 i
    ) = \ket{\Phi_e} \xrightarrow{P_{\d}^{(3)}}
    \mqty(
    0.0 i \\
    0.0 i \\
    0.0 i \\
    0.5+0.0 i \\
    0.0 i \\
    0.0 i \\
    0.0 i \\
    -0.5+0.0 i \\
    0.0 i \\
    0.0 i \\
    0.0 i \\
    0.0 i \\
    0.0 i \\
    0.0 i \\
    0.0 i \\
    0.71+0.0 i
    ) = \ket{\Phi_m}
\end{equation*}
We observed that we must renormalize the state after the projective measurement (see \cref{ssec:measurement}). Using the probability of the evolved state \(\ket{\Phi_e}\), as
\begin{equation*}
    \ket{\Phi_m} = \frac{P_{\d}^{(3)} \ket{\Phi_e}}{\sqrt{p_1}}, \qquad \quad p_1 = \ev**{P_{\d}^{(3)}}{\Phi_e}
\end{equation*}

We can see that we started with an equal superposition state \(\ket{\Psi}\), but the final state \(\ket{\Phi_m}\) has different properties compared to the starting state:
\begin{itemize}
    \item We can observe that the probability of finding qubits 3 and 4 in the state \(\ku\) is zero,
    \item probability of finding qubit 1 in the state \(\ku\) is \(1/2\),
    \item and the probability of finding qubit 2 in the state \(\kd\) is \(3/4\).
\end{itemize}


\section{Brickwork Structure}\label{sec:brickwork}

Extending our toy example, we now use a chain of \(L\) qubits under unitary dynamics as our quantum many-body system. The unitary evolution will be discrete in time \(t \in \Z\). For each time step \(t\), we will be having a unitary evolution operator \(U_t = U(t; t-1)\) and say at time \(t-1\) system is in state \(\ket{\psi_{t-1}}\) then state will evolve as
\begin{equation}
    \ket{\psi_t} = U_t \ket{\psi_{t-1}}
\end{equation}
Say we want to compute the final state of the system given the state at time \(t = 0\); we do as follows:
\begin{equation}
    U(t; 0) = U_t \cdots U_2 U_1 \qquad \implies \qquad \ket{\psi_t} = U(t; 0) \ket{\psi_0}
\end{equation}
\(U_t\) is a tensor product of local unitary operators acting on a pair of qubits.
\begin{equation}
    U_{\tau} = \begin{cases}
        \bigotimes\limits_{x \in \text{odd bonds}} u_{\tau, x}  & \text{if $\tau$ is odd},  \\[3ex]
        \bigotimes\limits_{x \in \text{even bonds}} u_{\tau, x} & \text{if $\tau$ is even}.
    \end{cases}
\end{equation}
We label all the pairwise unitary operators by the position of the control qubit as \(x\) (referred to as bonds). Here \(u_{\tau, x}\) is a local unitary operator acting on a pair of qubits connected by bond \(x\) (\ie a linear transformation on 4-dimensional Hilbert space), which is applied in time-step \(\tau\).

\begin{figure}[H]
    \[
        \Qcircuit @C=2em @R=2em {
        &&&&\mbox{Gen. 3}&&&\\
        & \lstick{1} & \multigate{1}{u_{1,1}} & \qw & \multigate{1}{u_{3,1}} & \qw & \multigate{1}{u_{5,1}} & \qw & \rstick{\cdots}\qw  \\
        & \lstick{2} & \ghost{u_{1,1}}        & \multigate{1}{u_{2,2}} & \ghost{u_{3,1}}        & \multigate{1}{u_{4,2}} & \ghost{u_{5,1}}        & \multigate{1}{u_{6,2}} & \rstick{\cdots}\qw  \\
        & \lstick{3} & \multigate{1}{u_{1,3}} & \ghost{u_{2,2}} & \multigate{1}{u_{3,3}} & \ghost{u_{4,2}} & \multigate{1}{u_{5,3}} & \ghost{u_{6,2}} & \rstick{\cdots}\qw  \\
        & \lstick{4} & \ghost{u_{1,3}}        & \multigate{1}{u_{2,4}} & \ghost{u_{3,3}}        & \multigate{1}{u_{4,4}} & \ghost{u_{5,3}}        & \multigate{1}{u_{6,4}} & \rstick{\cdots}\qw  \\
        & \lstick{5} & \multigate{1}{u_{1,5}} & \ghost{u_{2,4}} & \multigate{1}{u_{3,5}} & \ghost{u_{4,4}} & \multigate{1}{u_{5,5}} & \ghost{u_{6,4}} & \rstick{\cdots}\qw  \\
        & \lstick{6} & \ghost{u_{1,5}}        & \multigate{1}{u_{2,6}} & \ghost{u_{3,5}}        & \multigate{1}{u_{4,6}} & \ghost{u_{5,5}}        & \multigate{1}{u_{6,6}} & \rstick{\cdots}\qw  \\
        & \lstick{7} & \multigate{1}{u_{1,7}} & \ghost{u_{2,6}} & \multigate{1}{u_{3,7}} & \ghost{u_{4,6}} & \multigate{1}{u_{5,7}} & \ghost{u_{6,6}} & \rstick{\cdots}\qw  \\
        & \lstick{8} & \ghost{u_{1,7}}        & \qw & \ghost{u_{3,7}}        & \qw & \ghost{u_{5,7}}        & \qw & \rstick{\cdots}\qw
        \inputgroupv{2}{9}{1.5em}{0em}{}
        \inputgrouph{2}{9}{10.1em}{\H^{\otimes 8} \ni \ket{\psi}}{3.5em}
        \gategroup{2}{5}{9}{5}{1em}{--}
        }
    \]
    \caption{A spacetime diagram of 8 qubits RQC. This arrangement of two-site unitary gates will be called a brickwork structure.}
    \label{fig:brickwork}
\end{figure}
See \cref{fig:brickwork}, we have considered a chain of 8 qubits as our quantum many-body system. To become familiar with the notation regarding the unitary transformations, look at the marked generation 3. The unitary operator for \(2 \to 3\) transition is given by:
\begin{equation*}
    U_3 = \bigotimes_{x \in \text{odd bonds}} u_{3, x} = u_{3,1} \otimes u_{3,2} \otimes u_{3,5} \otimes u_{3,7}
\end{equation*}
We can see that the circuit grows from left to right, and the index \(\tau\) is increasing, implying the direction of time from \ie from left to the right.

If we construct our RQCs in this described fashion (\ie brickwork structure), we can note an underlying property that makes these circuits a good contender for QCAs \ie spatial locality. And if we introduce a fixed pattern on \(U_\tau\), we will retrieve time universality.\\

This circuit has \emph{no conservation laws} (even energy conservation is not conserved). But this system has local equilibrium states. Under the unitary evolution, an arbitrary initial state equilibrates to a local Gibbs state\footnote{\url{https://en.wikipedia.org/wiki/Gibbs_state}}.

\subsection{Measurements}\label{ssec:measurement}

We know what a measurement means in the context of quantum physics. But how this measurement affects our quantum circuits is something new. Measurements affect the state of a qubit. In RQCs, the state of the neighbouring qubits depends upon the state of the measured qubit. If the number of measurements is significant in a given spacetime volume (\ie in a defined random quantum circuit), we may see altered system dynamics.

Say we measure the \(i\)\textsuperscript{th} qubit in a given quantum circuit in computational basis (\ie \(Z\) basis). If the state of the quantum circuit before the measurement is given by \(\ket{\psi}\), then the state vector after measurement will be
\begin{equation}
    \ket{\psi} \to \begin{cases}
        \frac{P_\u^{(i)} \ket{\psi}}{p_\u^{(i)}} & \text{with probability \(p_\u^{(i)} = \ev**{P_\u^{(i)}}{\psi}\)} \\[4ex]
        \frac{P_\d^{(i)} \ket{\psi}}{p_\d^{(i)}} & \text{with probability \(p_\d^{(i)} = \ev**{P_\d^{(i)}}{\psi}\)}
    \end{cases}
\end{equation}
A local projective measurement disentangles the qubit \(i\) from the system.

If an RQC contains projective measurement operators, we call those circuits ``\vocab{monitored}'' quantum circuits. For classical computers, these monitored random quantum circuits work as models for a quantum phase transition in computational complexity.

\subsection{Extending Toy example}
See \cref{eg:toy-model} we can continue to apply unitary gates in the same manner (as constructed in \cref{sec:brickwork}). Consider using the brickwork structure on that example for four generations.
\begin{figure}[H]
    \[
        \Qcircuit @C=2.5em @R=2.5em @! {
        & \mbox{Gen 1} \barrier[-1.75em]{4} & \mbox{Gen 2} \barrier[-1.75em]{4} & \mbox{Gen 3} \barrier[-1.75em]{4} & \mbox{Gen 4} \barrier[-1em]{4} &         \\
        \lstick{\kr} & \ctrl{1} & \qw      & \ctrl{1} & \qw      & \rstick{\cdots} \qw \\
        \lstick{\kl} & \gate{H} & \ctrl{1} & \gate{H} & \ctrl{1} & \rstick{\cdots} \qw \\
        \lstick{\kr} & \ctrl{1} & \gate{H} & \ctrl{1} & \gate{H} & \rstick{\cdots} \qw \\
        \lstick{\kl} & \gate{H} & \qw      & \gate{H} & \qw      & \rstick{\cdots} \qw
        }
    \]
    \caption{Extended version of our toy model quantum circuit}
    \label{fig:toy-ext}
\end{figure}
Using the same methodology, we can compute the final state of this quantum system with the Julia program (see \cref{lst:toy-ext}). With the program, we can compute the final state for any generation \(\tau\) with the function \lstinline[language=julia]$state_evolution$
\begin{equation*}
    \ket{\Psi} = \mqty(
    0.25+0.0 i  \\
    -0.25+0.0 i \\
    0.25+0.0 i  \\
    -0.25+0.0 i \\
    -0.25+0.0 i \\
    0.25+0.0 i  \\
    -0.25+0.0 i \\
    0.25+0.0 i  \\
    0.25+0.0 i  \\
    -0.25+0.0 i \\
    0.25+0.0 i  \\
    -0.25+0.0 i \\
    -0.25+0.0 i \\
    0.25+0.0 i  \\
    -0.25+0.0 i \\
    0.25+0.0 i
    ) \xrightarrow{U(4; 0)}
    \mqty(
    0.25+0.0 i \\
    -0.25+0.0 i \\
    0.25+0.0 i \\
    -0.25+0.0 i \\
    0.0 i \\
    -0.35+0.0 i \\
    -0.25+0.0 i \\
    0.25+0.0 i \\
    0.177+0.0 i \\
    0.073+0.0 i \\
    -0.177+0.0 i \\
    0.427+0.0 i \\
    0.0 i \\
    -0.35+0.0 i \\
    -0.25+0.0 i \\
    0.25+0.0 i \\
    ) = \ket{\Phi_e^{(4)}}
\end{equation*}

\section{Fidelity -- a measure of memory}

Quantum Cellular Automata are essential for quantum computation as they give rise to exciting physics as we change gates and projective measurements. However, due to the peculiar nature of quantum physics, it is not easy to encode our classical information in quantum computers.

So, if we use quantum computers, we must check the output states (are they as expected or not). For the same, we require a quantity that works as an indicator in this case.
\begin{definition}[Fidelity]
    Fidelity measures ``overlap'' between two states from a given Hilbert space \(\H\). Consider two states \(\ket{\psi}, \ket{\phi} \in \H\); we define fidelity between these two states as follows:
    \begin{equation}
        F(\psi, \phi) = \abs{\ip{\psi}{\phi}}^2
    \end{equation}
\end{definition}
Fidelity can be interpreted in many different ways:
\begin{description}
    \item[\normalfont \uline{Probabilistic Interpretation:}] It is the probability that the state \(\ket{\psi}\) will pass the projective measurement onto the state \(\ket{\phi}\).
    \item[\normalfont \uline{Metric on Hilbert Space:}] It is the cosine of angular distance between two states in the given Hilbert space.\label{info:metric}
\end{description}

\noindent We can observe the following properties of this quantity:
\begin{itemize}
    \item {\sffamily Symmetry:} \(F(\psi, \phi) = F(\phi, \psi)\).
    \item {\sffamily Bounded Values:} For any \(\psi, \phi\), we have
          \begin{equation*}
              0 \le F(\phi, \psi) \le 1 \qquad \mbox{and} \qquad F(\psi, \psi) = 1 = F(\phi, \phi)
          \end{equation*}
\end{itemize}

\begin{remark}[Angle between two states]
    Building upon the ``metric'' interpretation, we define \emph{angle between two states} as:
    \begin{equation*}
        A(\psi, \phi) = \cos[-1](F(\psi, \phi)).
    \end{equation*}
    The angle is non-negative, symmetric in its inputs, and is equal to zero if and only if $\psi = \phi$. This follows triangle inequality, which implies this can be used as a metric for our interested space.
\end{remark}

\subsection{Use of Fidelity as a measure of memory}\label{ssec:fidelity}

Consider we encode information in the initial state for our RQC, and now we want to know how fast (or slow) our data gets lost in the quantum circuit. For the same, we can answer this question with the help of fidelity. Let's prepare an initial state, say
\begin{equation*}
    \ket{\psi} = \ket{\r \l \r \l}
\end{equation*}
And we vary our RQC as follows:
\begin{enumerate}
    \item For this system, we will use \(CY\) gate as our pairwise operator.
          \begin{figure}[H]
              \[
                  \Qcircuit @C=2em @R=2em {
                  \lstick{\kr} & \ctrl{1} & \qw      & \ctrl{1} & \qw      & \rstick{\cdots} \qw \\
                  \lstick{\kl} & \gate{Y} & \ctrl{1} & \gate{Y} & \ctrl{1} & \rstick{\cdots} \qw \\
                  \lstick{\kr} & \ctrl{1} & \gate{Y} & \ctrl{1} & \gate{Y} & \rstick{\cdots} \qw \\
                  \lstick{\kl} & \gate{Y} & \qw      & \gate{Y} & \qw      & \rstick{\cdots} \qw
                  }
              \]
              \caption{RQC with \(CY\) as pairwise operator with initial state $\ket{\psi}$}
              \label{fig:fidelity-CY}
          \end{figure}
          Now, if we calculate the fidelity of \(\tau\)\textsuperscript{th} generation and initial state. We get
          \begin{equation*}
              F_{\psi}(\tau) := F(\psi_\tau, \psi) = \abs{\ip{\psi_\tau}{\psi}}^2 \qquad \qquad \ket{\psi_\tau} = U(\tau; 0) \ket{\psi}
          \end{equation*}

          If plot Fidelity \(F_{\psi}(\tau)\) vs number of generation for \(0 \le \tau \le 100\), we get the following plot.
          \begin{figure}[H]
              \centering
              \resizebox{\textwidth}{!}{\input{images/fidelity_plot_CY.tikz}}
              \caption{Fidelity \(F_{\psi}(\tau)\) vs Number of generations \(\tau\) [for $CY$ operator]}
              \label{fig:fidelity-CY-plot}
          \end{figure}

    \item For this system, we will use \(CZ\) gate as our pairwise operator.
          \begin{figure}[H]
              \[
                  \Qcircuit @C=2em @R=2em {
                  \lstick{\kr} & \ctrl{1} & \qw      & \ctrl{1} & \qw      & \rstick{\cdots} \qw \\
                  \lstick{\kl} & \gate{Z} & \ctrl{1} & \gate{Z} & \ctrl{1} & \rstick{\cdots} \qw \\
                  \lstick{\kr} & \ctrl{1} & \gate{Z} & \ctrl{1} & \gate{Z} & \rstick{\cdots} \qw \\
                  \lstick{\kl} & \gate{Z} & \qw      & \gate{Z} & \qw      & \rstick{\cdots} \qw
                  }
              \]
              \caption{RQC with \(CZ\) as pairwise operator with initial state $\ket{\psi}$}
              \label{fig:fidelity-CZ}
          \end{figure}
          With the circuit in \cref{fig:fidelity-CZ}, we get the following graph if all the conditions are the same as for the \(CY\) case (see \cref{fig:fidelity-CY}).
          \begin{figure}[H]
              \centering
              \resizebox{\textwidth}{!}{\input{images/fidelity_plot_CZ.tikz}}
              \caption{Fidelity \(F_{\psi}(\tau)\) vs Number of generations \(\tau\) [for $CZ$ operator]}
              \label{fig:fidelity-CZ-plot}
          \end{figure}

    \item For this system, we will use our good old \(CH\) gate as our pairwise operator.
          \begin{figure}[H]
              \[
                  \Qcircuit @C=2em @R=1.8em {
                  \lstick{\kr} & \ctrl{1} & \qw      & \ctrl{1} & \qw      & \rstick{\cdots} \qw \\
                  \lstick{\kl} & \gate{H} & \ctrl{1} & \gate{H} & \ctrl{1} & \rstick{\cdots} \qw \\
                  \lstick{\kr} & \ctrl{1} & \gate{H} & \ctrl{1} & \gate{H} & \rstick{\cdots} \qw \\
                  \lstick{\kl} & \gate{H} & \qw      & \gate{H} & \qw      & \rstick{\cdots} \qw
                  }
              \]
              \caption{RQC with \(CH\) as pairwise operator with initial state $\ket{\psi}$}
              \label{fig:fidelity-CH}
          \end{figure}
          Considering the circuit in \cref{fig:fidelity-CH}, we get the following plot for the same,
          \begin{figure}[H]
              \centering
              \resizebox{\textwidth}{!}{\input{images/fidelity_plot_CH.tikz}}
              \caption{Fidelity \(F_{\psi}(\tau)\) vs Number of generations \(\tau\) [for $CH$ operator]}
              \label{fig:fidelity-CH-plot}
          \end{figure}
\end{enumerate}

\subsubsection{Observations \& Conclusion}
We can observe the following properties of these quantum circuits from these plots:
\begin{itemize}
    \item There are multiple instances where the fidelity is one other than for \(\tau = 0\), which implies the information is not entirely lost in these unitary transformations.

    \item In complement to that, we have many generations where the fidelity is zero, which means we have entirely lost the information we encoded in the initial state.

    \item If we look at the graphs, we can see the periodic nature of the fidelity. If we see each graph individually:
          \begin{enumerate}
              \item See \cref{fig:fidelity-CY-plot}, we can observe a periodic behavior of fidelity in the RQC with pairwise operator \(CY\). If we look at the fidelity values, we can determine the period to be \(8\) generations.

              \item See \cref{fig:fidelity-CZ-plot}, we can observe a periodic behavior of fidelity in the RQC with pairwise operator \(CZ\). If we look at the fidelity values, we can determine the period to be \(4\) generations.

              \item See \cref{fig:fidelity-CH-plot}, we can observe a periodic behavior of fidelity in the RQC with pairwise operator \(CH\). If we look at the fidelity values, we can determine the period to be \(48\) generations.
          \end{enumerate}
    \item In the case of \(CY\) and \(CH\), we can see there are secondary maxima as well, implying there are states between the full overlap and no overlap fidelities.
\end{itemize}

We can see these RQCs have a periodic nature for the initial states. Periodicity of fidelity in these circuits can be seen as an emergent property of these minimal-structured (or brickwork-structured) circuits. It also implies that these circuits have a memory of their initial states.


\section{Operator Spread -- Diffusion of expectation value}

In \cref{ssec:fidelity}, we have quantified a physical quantity named ``Fidelity'', which measures an RQC's memory. Now, let's focus on the problem of how well an RQC transmits information.

Consider we encoded some classical information in the expectation value of an operator for a quantum system. So, we want to find the transmission of the expectation value of that operator through the whole system.
\begin{definition}[Expectation Value]
    The expectation value is the probabilistic expected value of a measurement of a quantum state.

    \noindent Consider an operator \(\mathcal{O}\) defined on a Hilbert space \(\H\) corresponding to a quantum system. The expectation value is defined as
    \begin{equation}
        \expval{\mathcal{O}}_{\psi} = \ev**{\mathcal{O}}{\psi}
    \end{equation}
    for any normalized quantum state \(\ket{\psi} \in \H\).
\end{definition}

Consider a quantum many-body system composed of 8 qubits, evolving through time under the \(CH\) gate arranged in brickwork fashion. In this case, our classical information is encoded by operator \(S_Z\).
\begin{equation*}
    S_Z = \mqty(1 & 0 \\ 0 & -1)
\end{equation*}
For transmission purposes, say at site 4 (\ie 4\textsuperscript{th} qubit), the expectation value of this operator is non-zero (= 1), and at all other sites, it is zero. We have to construct an initial state that satisfies all these properties, and the easiest state is
\begin{equation*}
    \ket{\psi} = \kr \otimes \kl \otimes \kl \otimes \ku \otimes \kr \otimes \kl \otimes \kr \otimes \kl
\end{equation*}
Now, if we look at the corresponding quantum circuit schematic
\begin{figure}[H]
    \[
        \Qcircuit @C=2em @R=2em {
        & \lstick{\kr} & \ctrl{1}    & \qw      & \ctrl{1}    & \qw      & \ctrl{1}    & \qw      & \rstick{\cdots} \qw \\
        & \lstick{\kl} & \gate{H} & \ctrl{1}    & \gate{H} & \ctrl{1}    & \gate{H} & \ctrl{1}    & \rstick{\cdots} \qw \\
        & \lstick{\kl} & \ctrl{1}    & \gate{H} & \ctrl{1}    & \gate{H} & \ctrl{1}    & \gate{H} & \rstick{\cdots} \qw \\
        & \lstick{\ku} & \gate{H} & \ctrl{1}    & \gate{H} & \ctrl{1}    & \gate{H} & \ctrl{1}    & \rstick{\cdots} \qw \\
        & \lstick{\kr} & \ctrl{1}    & \gate{H} & \ctrl{1}    & \gate{H} & \ctrl{1}    & \gate{H} & \rstick{\cdots} \qw \\
        & \lstick{\kl} & \gate{H} & \ctrl{1}    & \gate{H} & \ctrl{1}    & \gate{H} & \ctrl{1}    & \rstick{\cdots} \qw \\
        & \lstick{\kr} & \ctrl{1}    & \gate{H} & \ctrl{1}    & \gate{H} & \ctrl{1}    & \gate{H} & \rstick{\cdots} \qw \\
        & \lstick{\kl} & \gate{H} & \qw      & \gate{H} & \qw      & \gate{H} & \qw      & \rstick{\cdots} \qw
        }
    \]
    \caption{RQC with \(CH\) as pairwise operator with initial state $\ket{\psi}$}
    \label{fig:spread-circuit}
\end{figure}

Let's create a heatmap plot that shows the flow of the expectation value of the \(S_Z\) operator with flowing time \(\tau\). With the different colors of the heatmap, we can deduce the direction of transmission and even speed.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{spread-Sz.png}
    \caption{Heatmeat showing the spread of the information which is stored in qubit four at time \(\tau = 0\).}
    \label{fig:spread}
\end{figure}

\subsection{Observation and Conclusion}
With the heat map plot, we can deduce the following properties of this system:
\begin{enumerate}
    \item For qubit one, operator \(S_Z\) has an expectation value of zero, which implies there is no gain of information by qubit one.

    \item For qubits two to seven, the expectation value of operator \(S_Z\) has increased after the first generation. However, there are multiple instances where the value also touches zero, implying these qubits get information but very superficially. Qubits get the information but cannot store it for long.

    \item For qubit eight, we see a continuous band of dark green color, implying a very high expectation value of operator \(S_Z\), indicating that information has traveled from qubit four to eight and gets stored there.
\end{enumerate}

From these properties, we can imply that the information encoded in qubit four has traveled to eight, spreading information in bits and pieces to qubits two to seven, suggesting that the spread is constant and then it just stays there.


\appendix

\chapter{Quantum Computers}

\section{Quantum Gates}

In \cref{ssec:quantum-computer}, we have gone through a few quantum gates. Now, we will look at all the quantum logic gates.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{Quantum_Logic_Gates.png}
    \caption[Table of all quantum logic gates]{Table of all quantum logic gates\protect\footnotemark}
    \label{fig:quantum-logic-gates}
\end{figure}
\footnotetext{\url{https://en.wikipedia.org/wiki/Quantum_logic_gate}}

\chapter{Code}\label{appendix:code}

\noindent This chapter contains all the codes used to generate the graphs or numerical results. All the program files are hosted on my \texttt{github}. To see them, visit: \href{https://github.com/iamPiyushKrSingh/NIUS-Physics-20.2/tree/main/codes}{code files}.

\section[Classical Cellular Automata]{Cellular Automata}

This section contains the code used to generate the heatmap diagram for CA named rule-110.
\lstinputlisting[language=julia, caption={Generating Spacetime diagram of CA \texttt{rule 110}}, label={lst:rule110}]{./codes/rule-110.jl}

\section{Toy example}

\lstinputlisting[language=Mathematica, caption={Computing matrix of CH gate}, label={lst:CH-mat}]{./codes/CH.txt}

\lstinputlisting[language=julia, caption={Simulating the final state of toy example using matrix operations}, label={lst:toy-final}]{./codes/toy-model.jl}

\lstinputlisting[language=julia, caption={Simulating the final state of our extended system using matrix operations}, label={lst:toy-ext}]{./codes/toy-ext.jl}

\section{Fidelity Calculations}

\lstinputlisting[language=julia, caption={Plotting fidelity vs increasing generations}, label={lst:fidelity}]{./codes/fidelity.jl}

\section{Operator Spread}

\lstinputlisting[language=julia, caption={Spread of expectation value of operator \(Z\)}, label={lst:spread}]{./codes/spread.jl}

\backmatter\printbibliography[heading=bibintoc, title=Bibliography]

\end{document}